name: CI

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master, develop]
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  GO_VERSION: '1.25.x'
  CACHE_VERSION: v3

jobs:
  # =============================================================================
  # PHASE 1: Independent Validation (All run in parallel)
  # =============================================================================

  format-check:
    name: Format Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v8
        with:
          logger: pretty

      - name: Check Nix formatting
        run: |
          echo "Checking Nix file formatting..."
          nix run nixpkgs#nixpkgs-fmt -- --check . || {
            echo "Nix formatting check failed. Run 'nixpkgs-fmt .' to fix."
            exit 1
          }

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Install gofumpt
        run: go install mvdan.cc/gofumpt@latest

      - name: Check Go formatting
        run: |
          echo "Checking Go formatting..."
          if [ "$(gofumpt -l . | wc -l)" -gt 0 ]; then
            echo "Go formatting issues found:"
            gofumpt -l .
            echo "Run 'gofumpt -w .' to fix."
            exit 1
          fi

      - name: Nix flake check (basic)
        run: |
          echo "Basic Nix flake validation..."
          nix flake check --no-build

  lint:
    name: Lint (${{ matrix.module }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        module: [core, runtime, cli]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v7
        with:
          version: v2.4.0
          working-directory: ${{ matrix.module }}
          args: --timeout=5m --verbose

  build:
    name: Build (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        include:
          - os: ubuntu-latest
            goos: linux
            goarch: amd64
          - os: macos-latest
            goos: darwin
            goarch: amd64
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          echo "Building opal for ${{ matrix.goos }}/${{ matrix.goarch }}..."
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
          BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          go build -ldflags="-s -w -X main.Version=${VERSION} -X main.BuildTime=${BUILD_TIME}" \
            -o opal-${{ matrix.goos }}-${{ matrix.goarch }} \
            ./cli/main.go

      - name: Test binary
        run: |
          echo "Testing built binary..."
          ./opal-${{ matrix.goos }}-${{ matrix.goarch }} --help

          echo 'test: echo "Binary test successful"' > test.opl
          ./opal-${{ matrix.goos }}-${{ matrix.goarch }} --dry-run -f test.opl test

      - name: Upload binary
        uses: actions/upload-artifact@v4
        with:
          name: opal-${{ matrix.goos }}-${{ matrix.goarch }}
          path: opal-${{ matrix.goos }}-${{ matrix.goarch }}

  nix-development:
    name: Nix Development (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v8
        with:
          logger: pretty

      - name: Test development shell
        run: |
          echo "Testing Nix development shell..."
          nix develop --command echo "Development shell provides dependencies!"

      - name: Verify Go tools in Nix shell
        run: |
          echo "Verifying Go tools are available in Nix shell..."
          nix develop --command go version
          nix develop --command gofumpt --version || echo "gofumpt not required in shell"

  # =============================================================================
  # PHASE 2: Core Foundation (Needs linting to pass)
  # =============================================================================

  test-core:
    name: Test Core Module
    runs-on: ubuntu-latest
    needs: [lint]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Run core module tests
        run: |
          echo "Running core module tests..."
          cd core
          go test -v -race -coverprofile=../coverage-core.out -covermode=atomic ./...

      - name: Upload core coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-core
          path: coverage-core.out

  # =============================================================================
  # PHASE 3: Module Testing (All run in parallel after core)
  # =============================================================================

  test-runtime:
    name: Test Runtime Module
    runs-on: ubuntu-latest
    needs: [test-core]
    timeout-minutes: 15
    permissions:
      contents: read
      actions: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Snapshot fuzz corpus
        run: |
          set -euo pipefail
          echo "==> Fuzz corpus snapshot"
          CORPUS_COUNT=$(find testdata/fuzz -type f 2>/dev/null | wc -l || echo 0)
          CORPUS_BYTES=$(du -sb testdata/fuzz 2>/dev/null | cut -f1 || echo 0)
          CORPUS_SIZE=$(du -sh testdata/fuzz 2>/dev/null | cut -f1 || echo "0")
          echo "Corpus files: $CORPUS_COUNT"
          echo "Corpus size: $CORPUS_SIZE ($CORPUS_BYTES bytes)"
          echo "corpus_count=$CORPUS_COUNT" >> $GITHUB_OUTPUT
          echo "corpus_size=$CORPUS_SIZE" >> $GITHUB_OUTPUT
          echo "corpus_bytes=$CORPUS_BYTES" >> $GITHUB_OUTPUT
        id: corpus_snapshot

      - name: Run runtime tests + corpus replay
        run: |
          set -euo pipefail
          echo "Running runtime tests with race detector..."
          cd runtime
          # Test all available runtime packages (execution package was removed in clean slate)
          # Corpus replay happens automatically via go test (no -fuzz flag)
          go test -v -race -coverprofile=../coverage-runtime.out -covermode=atomic ./...
          
          echo ""
          echo "==> Corpus replay complete"
          echo "All fuzz corpus files validated (count: ${{ steps.corpus_snapshot.outputs.corpus_count }})"

      - name: Upload runtime coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-runtime
          path: coverage-runtime.out



  test-cli:
    name: Test CLI Module Build
    runs-on: ubuntu-latest
    needs: [test-core]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Test CLI build and basic functionality
        run: |
          echo "Testing CLI build and interpreter mode..."
          cd cli
          go build -o opal .

          ./opal --help

          echo 'test: echo "CI test successful"' > test.opl
          ./opal --dry-run -f test.opl test

  # =============================================================================
  # PHASE 4: Aggregation (After all tests)
  # =============================================================================

  aggregate-coverage:
    name: Aggregate Coverage
    runs-on: ubuntu-latest
    needs: [test-core, test-runtime]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Download all coverage reports
        uses: actions/download-artifact@v4
        with:
          path: coverage-artifacts/

      - name: Merge coverage reports
        run: |
          echo "Merging coverage reports..."
          find coverage-artifacts/ -name "*.out" -exec cp {} . \;

          echo "mode: atomic" > coverage.out
          tail -n +2 coverage-*.out | grep -v "mode: atomic" >> coverage.out || true

      - name: Upload merged coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.out
          flags: unittests
          name: codecov-umbrella

      - name: Archive merged coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report-merged
          path: coverage.out

  # =============================================================================
  # SUMMARY: Collect all results
  # =============================================================================

  summary:
    name: CI Summary
    runs-on: ubuntu-latest
    needs: [format-check, lint, build, nix-development, test-core, test-runtime, test-cli, aggregate-coverage]
    if: always()
    steps:
      - name: Check job statuses
        run: |
          echo "CI Pipeline Summary"
          echo "================================"

          jobs=(
            "${{ needs.format-check.result }}:Format Check"
            "${{ needs.lint.result }}:Lint"
            "${{ needs.build.result }}:Build"
            "${{ needs.nix-development.result }}:Nix Development"
            "${{ needs.test-core.result }}:Test Core"
            "${{ needs.test-runtime.result }}:Test Runtime"
            "${{ needs.test-cli.result }}:Test CLI"
            "${{ needs.aggregate-coverage.result }}:Coverage Report"
          )

          all_passed=true
          for job in "${jobs[@]}"; do
            status="${job%%:*}"
            name="${job##*:}"
            case $status in
              success) echo "✅ $name" ;;
              failure) echo "❌ $name"; all_passed=false ;;
              cancelled) echo "⏹️  $name"; all_passed=false ;;
              skipped) echo "⏭️  $name" ;;
              *) echo "❓ $name ($status)"; all_passed=false ;;
            esac
          done

          echo "================================"
          if [ "$all_passed" = true ]; then
            echo "🎉 All CI jobs passed successfully!"
          else
            echo "❌ Some CI jobs failed. Check the logs above."
            exit 1
          fi

  # =============================================================================
  # LATEST BUILDS (only on main/master)
  # =============================================================================

  latest-builds:
    name: Latest Development Builds
    runs-on: ubuntu-latest
    needs: [summary]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Prepare development builds
        run: |
          echo "Preparing latest development builds..."
          mkdir -p latest/

          find artifacts/ -name 'opal-*' -type f -exec cp {} latest/ \;

          echo "Built from commit: ${{ github.sha }}" > latest/build-info.txt
          echo "Built at: $(date -u)" >> latest/build-info.txt
          echo "Branch: ${{ github.ref_name }}" >> latest/build-info.txt

      - name: Archive latest builds
        uses: actions/upload-artifact@v4
        with:
          name: latest-dev-builds
          path: latest/
          retention-days: 30

  # =============================================================================
  # RELEASE (only when tags are pushed)
  # =============================================================================

  release:
    name: Create Release
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v8
        with:
          logger: pretty

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true

      - name: Get version from tag
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Build release binaries
        run: |
          echo "Building release binaries for ${{ steps.version.outputs.version }}..."

          platforms=(
            "linux/amd64"
            "linux/arm64"
            "darwin/amd64"
            "darwin/arm64"
            "windows/amd64"
          )

          mkdir -p release/

          for platform in "${platforms[@]}"; do
            GOOS=${platform%/*}
            GOARCH=${platform#*/}

            echo "Building for $GOOS/$GOARCH..."

            if [ "$GOOS" = "windows" ]; then
              BINARY_NAME="opal-$GOOS-$GOARCH.exe"
            else
              BINARY_NAME="opal-$GOOS-$GOARCH"
            fi

            CGO_ENABLED=0 GOOS=$GOOS GOARCH=$GOARCH go build \
              -ldflags="-s -w -X main.Version=${{ steps.version.outputs.version }} -X main.BuildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              -o "release/$BINARY_NAME" \
              ./cli/main.go
          done

      - name: Create checksums
        run: |
          echo "Creating checksums..."
          cd release/

          for file in opal-*; do
            if [ -f "$file" ]; then
              sha256sum "$file" >> checksums.txt
            fi
          done

      - name: Create release
        uses: softprops/action-gh-release@v1
        with:
          draft: false
          prerelease: ${{ contains(steps.version.outputs.version, '-') }}
          files: |
            release/opal-*
            release/checksums.txt
          generate_release_notes: true
          body: |
            ## 🚀 Devcmd ${{ steps.version.outputs.version }}

            **Declarative CLI Tool - Interpreter Mode**

            ### ✅ Available Features
            - **Interpreter Mode**: Run commands directly with `opal run <command>`
            - **Shell Operators**: Support for `&&`, `||`, `|`, `>>`
            - **Variable Substitution**: `@var(NAME)` syntax
            - **Plan Generation**: `--dry-run` mode
            - **Standardized Flags**: `--quiet`, `--verbose`, `--ci`, etc.

            ### 📦 Downloads
            - **Linux (x64)**: `opal-linux-amd64`
            - **Linux (ARM64)**: `opal-linux-arm64`
            - **macOS (Intel)**: `opal-darwin-amd64`
            - **macOS (Apple Silicon)**: `opal-darwin-arm64`
            - **Windows (x64)**: `opal-windows-amd64.exe`

            ### 🚧 Coming Soon
            - Standalone CLI generation (Generator Mode)
            - Advanced decorators (@workdir, @timeout, @parallel)

            ### ✅ Verification
            Verify downloads with SHA256 checksums in `checksums.txt`.

            ### 📚 Documentation
            See README.md for usage instructions and examples.
