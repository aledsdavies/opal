---
oep: 012
title: Module Composition and Plugin System
status: Draft
type: Integration
created: 2025-01-21
updated: 2025-01-27
---

# OEP-012: Module Composition and Plugin System

## Summary

Add a comprehensive plugin system for sharing reusable decorators and schemas. Support WebAssembly and native plugins, registry-based distribution, and git repository sources. Plugins are registered globally via a mod file. Plugins provision resources and prepare transport contexts; Opal executes blocks remotely under the plugin's transport.

## Motivation

### The Problem

Current Opal has no plugin system:
- No way to share reusable decorators
- No way to distribute plugins
- No way to version dependencies
- No way to use git repositories as sources
- No plugin registry

### Use Cases

**1. Registry-based plugin installation:**
```bash
opal add hashicorp/aws@5.0.0
opal add company/custom-decorators@1.2.3
opal list
opal update hashicorp/aws
```

**2. Git repository sources:**
```bash
opal add github.com/company/opal-aws@v1.2.3
opal add gitlab.com/team/opal-utils@main
opal add git.company.com/ops/opal-internal@v2.0.0
```

**3. Global plugin usage (no imports needed):**
```opal
// opal.mod registers plugins globally
// All decorators available without import

deploy: {
    @aws.instance.deploy(name="web", ami="ami-123", type="t3.medium") {
        sudo systemctl enable nginx
        curl http://127.0.0.1/health
    }
}
```

**4. Terraform provider bridge:**
```bash
opal add terraform/hashicorp/aws@5.0.0
# Automatically generates decorators, available globally as @aws.*
```

## Proposal

### Plugin Registration (opal.mod)

#### Mod File Structure

```toml
# opal.mod - project plugin manifest
[plugins]
# Registry plugins
hashicorp/aws = "5.0.0"
company/custom = "1.2.3"

# Git repository plugins
github.com/company/opal-k8s = "v1.0.0"
gitlab.com/team/opal-utils = "main"

# Local plugins
./local/custom-plugin = "1.0.0"

# Terraform providers (auto-generates decorators)
terraform/hashicorp/aws = "5.0.0"
terraform/hashicorp/kubernetes = "2.0.0"
```

#### Lock File (opal.lock)

```toml
# opal.lock - generated by opal, committed to version control
[[plugin]]
name = "hashicorp/aws"
version = "5.0.0"
source = "registry+https://registry.opal.dev/hashicorp/aws"
checksum = "sha256:a1b2c3d4..."

[[plugin]]
name = "github.com/company/opal-k8s"
version = "v1.0.0"
source = "git+https://github.com/company/opal-k8s?tag=v1.0.0"
checksum = "sha256:e5f6g7h8..."
```

### Plugin Architecture

#### Plugin Responsibilities

Plugins are **host-driven**: they provision resources and prepare transport contexts, then hand execution back to Opal.

**Plugin responsibilities:**
1. **Plan-time advise**: Resolve intended resource spec, produce idempotency key
2. **Execute**:
   - Ensure resource exists (create or adopt by idempotency key)
   - Wait/ready: probe until reachable (port open, SSM online, etc.)
   - Prepare transport handle (SSH, SSM, or other)
   - Return handle to host (never execute block inside plugin)

#### Host Responsibilities

Opal (the host) remains in control:

1. **Wrap execution context** with RemoteContext from plugin
2. **Execute block steps** via wrapped context:
   - Schedule child steps (deterministic order)
   - Handle `@retry`, `@timeout`, secret scrubbing
   - Deterministic output merge
3. **Teardown** after block completes

#### Execution Flow

```
1. Plan: decorator appears with params; block exists → marked "remote block"

2. Run:
   - BeginExec(params) → returns remote_handle(transport, targets, user, host)
   - Host: ctx' = ctx.WithRemote(remote_handle)
   - Host: ExecuteBlock(block) under ctx'
   - EndExec(token)

3. WithRemote redirects:
   - @shell commands run over SSH/SSM
   - Environment variables passed to remote
   - Files transferred as needed
   - Stdout/stderr kept deterministic and scrubbed
```

### Plugin Interface (DIM Manifest)

Plugins declare their interface via a DIM (Decorator Interface Manifest) file.

#### Manifest Format

DIM manifests use **JSON Schema Draft 2020-12** as the foundation, ensuring compatibility with standard tooling and validators. Opal-specific extensions use the `x-opal-*` prefix.

**Why JSON Schema?**
- ✅ Industry standard (OpenAPI, Kubernetes, Terraform)
- ✅ Extensive tooling (validators, generators, IDE support)
- ✅ Interoperability (can import existing schemas)
- ✅ Future-proof (active development, backward compatible)

**Manifest structure:**

```yaml
# DIM manifest (JSON Schema based)
$schema: https://json-schema.org/draft/2020-12/schema
$id: https://plugins.opal.dev/aws/ec2/v1.0.0

# Opal-specific metadata
x-opal-plugin:
  name: aws.ec2
  version: 1.0.0
  min_core: 0.4.0

# Decorator definitions
x-opal-decorators:
  - name: aws.instance.deploy
    $id: https://plugins.opal.dev/aws/ec2/v1.0.0/instance-deploy
    summary: Deploy EC2 instance with optional remote execution
    
    # Parameter schema (JSON Schema)
    params:
      type: object
      properties:
        name:
          type: string
          pattern: "^[a-z0-9-]+$"
          description: Instance name
        ami:
          type: string
          description: AMI ID
        instance_type:
          type: string
          description: Instance type
        region:
          type: string
          description: AWS region
        count:
          type: integer
          minimum: 1
          maximum: 100
          default: 1
        transport:
          # Enum with Opal extension for deprecation
          enum: ["ssh", "ssm"]
          default: "ssm"
          x-opal-deprecated-values:
            telnet: "Use ssh or ssm instead"
        ready_probe:
          type: object
          properties:
            port:
              type: integer
              minimum: 1
              maximum: 65535
            cmd:
              type: string
            timeout:
              type: string
              x-opal-duration: true  # Opal duration type
              default: "5m"
          required: [timeout]
          additionalProperties: false  # Closed by default
      required: [name, ami, instance_type, region]
      additionalProperties: false
    
    # Return schema (versioned, hashed)
    returns:
      $id: https://plugins.opal.dev/aws/ec2/v1.0.0/instance-deploy/returns
      version: 1.0.0
      type: object
      properties:
        instance_id:
          type: string
          description: EC2 instance ID
        public_ip:
          type: string
          format: ipv4
        state:
          enum: ["pending", "running", "stopped"]
      required: [instance_id, state]
      additionalProperties: false
    
    # Block support
    x-opal-block: optional  # optional, required, or forbidden
    
    # Capabilities (for role inference)
    x-opal-capabilities: [net, clock]
```

#### Type System

DIM manifests support a **narrowed JSON Schema subset** optimized for type-safety and determinism:

**Primitive types:**
- `string` - With optional `pattern`, `minLength`, `maxLength`
- `integer` - With optional `minimum`, `maximum` (no implicit coercion)
- `number` - With optional `minimum`, `maximum`
- `boolean` - True/false values
- `enum` - Enumerated values with compile-time validation
- `duration` - Opal extension (`x-opal-duration: true`) for "1s", "5m", "2h"

**Complex types:**
- `object` - Structured data with `properties`, `required`, `additionalProperties: false` (default)
- `array` - Typed arrays with `items` (homogeneous only, no tuples)

**Typed formats** (nominal types via `format` keyword):
- `uri`, `hostname`, `ipv4`, `ipv6`, `cidr`
- `semver` (Opal extension: `x-opal-format: semver`)

**Discriminated unions** (Opal extension):
```yaml
# Tagged union via x-opal-union
x-opal-union:
  discriminator: type
  cases:
    ssh:
      type: object
      properties:
        type: { const: "ssh" }
        user: { type: string }
        key: { type: string }
      required: [type, user, key]
    ssm:
      type: object
      properties:
        type: { const: "ssm" }
        profile: { type: string }
      required: [type]
```

**Determinism guarantees:**
- ❌ No implicit coercion (`"3"` stays string, never becomes `3`)
- ❌ No `oneOf`, `anyOf`, `allOf` (use discriminated unions instead)
- ❌ No tuple schemas (arrays must be homogeneous)
- ✅ Closed objects by default (`additionalProperties: false`)
- ✅ Duration normalization (`90m` → `1h30m` canonical form)
- ✅ Null forbidden by default (explicit opt-in: `type: ["integer", "null"]`)

#### Manifest Loading and Availability

**Plugin manifests must be available at all phases:**

**1. Compile-time (Parse):**
- Parser validates decorator parameters against manifest schemas
- Type errors reported immediately (no runtime surprises)
- Manifests loaded from `opal.lock` (deterministic, versioned)

**2. Plan-time:**
- Planner includes manifest metadata in plan
- Return schemas tracked with `$id` and content hash
- Capability checks enforced (block policies, transport requirements)

**3. Execution-time:**
- Executor validates return values against manifest schemas
- Semver compatibility checks (major version must match)
- Content hash verification (detect schema changes without version bump)

**Manifest resolution:**

```
1. opal.mod declares plugin dependencies
   hashicorp/aws = "5.0.0"

2. opal install resolves and locks
   → Downloads plugin binary + DIM manifest
   → Writes opal.lock with checksums
   → Caches in ~/.opal/plugins/

3. Parser loads manifests from lock file
   → Validates all decorator usage at parse-time
   → No runtime type errors

4. Planner embeds manifest metadata in plan
   → Plan includes decorator schemas ($id + hash)
   → Contract verification detects schema changes

5. Executor validates against embedded schemas
   → Return values checked at runtime
   → Semver compatibility enforced
```

**Manifest caching:**
- Manifests cached by content hash (immutable)
- Validator instances memoized (performance)
- No remote fetches during execution (security)

**Schema evolution:**
- Plans track decorator schema `$id` + version + hash
- Executor refuses mismatched major versions (breaking changes)
- Minor version increases allowed (additive changes)
- Hash mismatch for same version → error (schema changed without version bump)

### Role Auto-Inference from DIM Manifest

**Design Principle**: Plugin authors specify capabilities, not roles. Opal runtime automatically infers decorator roles from the manifest.

#### Inference Rules

| Manifest Feature | Inferred Role | Example |
|------------------|---------------|---------|
| `returns: { ... }` | `RoleProvider` | Value decorators that produce data |
| `x-opal-block: required/optional` | `RoleWrapper` | Execution decorators that wrap blocks |
| `x-opal-block: required` + `x-opal-transport: true` | `RoleBoundary` | Transport decorators (SSH, Docker) |
| `x-opal-io: { redirect_in: true }` or `redirect_out: true` | `RoleEndpoint` | I/O endpoints (files, S3, HTTP) |

**Note**: `RoleWrapper` may be renamed to `RoleExecutor` for clarity (execution decorators that wrap work).

#### Multi-Role Decorators

Decorators can have multiple roles by declaring multiple capabilities:

```yaml
x-opal-decorators:
  - name: aws.s3.object
    $id: https://plugins.opal.dev/aws/s3/v1.0.0/object
    
    # Parameters
    params:
      type: object
      properties:
        bucket: { type: string }
        key: { type: string }
      required: [bucket, key]
    
    # Returns (infers RoleProvider)
    returns:
      $id: https://plugins.opal.dev/aws/s3/v1.0.0/object/returns
      version: 1.0.0
      type: object
      properties:
        size:
          type: integer
          description: Object size in bytes
        etag:
          type: string
          description: Object ETag
        url:
          type: string
          format: uri
          description: S3 URL
        lastModified:
          type: string
          format: date-time
      required: [size, etag, url]
    
    # I/O capabilities (infers RoleEndpoint)
    x-opal-io:
      redirect_out: true
    
    # Opal runtime auto-infers:
    # Roles: [RoleProvider, RoleEndpoint]
```

**Usage as Value (RoleProvider):**
```opal
var obj = @aws.s3.object(bucket="artifacts", key="build.tar.gz")
echo "Size: @var.obj.size bytes"
echo "ETag: @var.obj.etag"
```

**Usage as Endpoint (RoleEndpoint):**
```opal
tar czf - dist/ > @aws.s3.object(bucket="artifacts", key="build.tar.gz")
```

#### Minimal Manifests

Roles are always inferred from capabilities - no need to specify explicitly:

```yaml
x-opal-decorators:
  - name: retry
    $id: https://plugins.opal.dev/core/retry/v1.0.0
    
    params:
      type: object
      properties:
        attempts:
          type: integer
          minimum: 1
          maximum: 10
          default: 3
        delay:
          type: string
          x-opal-duration: true
          default: "1s"
        strategy:
          enum: ["constant", "exponential", "linear"]
          default: "exponential"
      additionalProperties: false
    
    x-opal-block: required  # ← Infers RoleWrapper (or RoleExecutor)
    
    # Opal runtime auto-infers:
    # Roles: [RoleWrapper]
```

#### Benefits

1. **Less boilerplate** - Authors specify what decorators do, not how they're classified
2. **Type-safe** - Roles always match declared capabilities
3. **Consistent** - Same inference logic for native Go and plugin decorators
4. **Clear semantics** - Manifest features directly map to user-visible behavior
5. **JSON Schema compatible** - All Opal extensions use `x-opal-*` prefix

### Plugin Execution ABIs

**Language-agnostic:** WASM and native (.so) plugins can be implemented in any language that compiles to WebAssembly or native code (Rust, Go, C++, Zig, AssemblyScript, etc.).

#### WASM ABI

Plugins implement these functions:

**BeginExec** (create/ensure resource)
- Input: `params_json`
- Output: `policy_token`, `remote_handle_json` (targets, transport, user), `teardown_hint`

**OnChildStart/Finish** (optional policy hooks)
- For telemetry or per-target failure policy

**EndExec** (cleanup)
- Input: `policy_token`, `teardown_hint`
- Allows cleanup using plugin's internal state

#### Native Plugin ABI

Native plugins (`.so` files) implement C-compatible vtable:

```c
typedef struct {
    void* (*begin_exec)(const char* params_json, char** remote_handle_json, char** teardown_hint);
    void (*on_child_start)(void* token, int target_idx);
    void (*on_child_finish)(void* token, int target_idx, int exit_code);
    void (*end_exec)(void* token, const char* teardown_hint);
} OpalPluginVTable;
```

### Plugin Structure

#### Plugin Package

```
opal-aws/
├── opal.toml                 # Plugin manifest
├── dim.yaml                  # Decorator interface manifest
├── decorators/
│   ├── instance.opl
│   ├── s3.opl
│   └── rds.opl
├── schemas/
│   ├── instance.schema.json
│   └── s3.schema.json
├── plugins/
│   ├── aws-provider.wasm     # WebAssembly plugin
│   └── aws-provider.so       # Native plugin (optional)
└── README.md
```

#### Plugin Manifest (opal.toml)

```toml
[package]
name = "hashicorp/aws"
version = "5.0.0"
authors = ["HashiCorp <team@hashicorp.com>"]
description = "AWS provider for Opal"
license = "MPL-2.0"
repository = "https://github.com/hashicorp/opal-aws"

[dependencies]
"opal/core" = "^0.1.0"

[decorators]
# Exported decorators (available globally)
exports = [
    "aws.instance.deploy",
    "aws.s3.bucket.ensure",
    "aws.rds.create"
]

[plugins]
# WebAssembly plugin (recommended)
wasm = "plugins/aws-provider.wasm"
# Native plugin (optional, for performance)
native = "plugins/aws-provider.so"
```

### Plugin Registry

#### Registry Structure

```
registry.opal.dev/
├── hashicorp/
│   ├── aws/
│   │   ├── 5.0.0/
│   │   │   ├── plugin.tar.gz
│   │   │   ├── plugin.tar.gz.sha256
│   │   │   └── manifest.json
│   │   └── versions.json
│   └── terraform/
│       └── ...
└── company/
    └── custom-decorators/
        └── ...
```

#### Registry Commands

```bash
# Add plugin from registry
opal add hashicorp/aws@5.0.0

# Add from git repository
opal add github.com/company/opal-aws@v1.2.3

# Update plugin
opal update hashicorp/aws

# Remove plugin
opal remove hashicorp/aws

# List installed plugins
opal list

# Search registry
opal search aws

# Show plugin info
opal info hashicorp/aws
```

### Git Repository Integration

#### Adding from Git

```bash
# Add from GitHub
opal add github.com/company/opal-aws@v1.2.3

# Add from GitLab
opal add gitlab.com/team/opal-utils@main

# Add from private repo (uses SSH keys)
opal add git@github.com:company/private-plugin.git@v2.0.0
```

#### Version Resolution

```bash
# Semantic versioning
opal add github.com/company/plugin@v1.2.3  # Exact version
opal add github.com/company/plugin@v1.2    # Latest patch (1.2.x)
opal add github.com/company/plugin@v1      # Latest minor (1.x.x)

# Git references
opal add github.com/company/plugin@main    # Branch
opal add github.com/company/plugin@abc123  # Commit hash
opal add github.com/company/plugin@v1.2.3  # Tag
```

### Core Restrictions

#### Restriction 1: Plugins are immutable

Once published, plugin versions cannot be modified.

**Why?** Reproducibility. Builds must be deterministic.

#### Restriction 2: Plugins never execute blocks

Plugins provision resources and return transport context. Opal executes blocks.

**Why?** Host remains in control. Determinism and security.

#### Restriction 3: Plugins cannot write to stdout

Plugins must return opaque handles. No raw secrets in logs.

**Why?** Security. Secrets must be scrubbed.

#### Restriction 4: Version constraints must be explicit

Dependencies must specify version constraints (no wildcards).

**Why?** Reproducibility. Builds must be deterministic.

#### Restriction 5: Circular dependencies are forbidden

Plugins cannot have circular dependencies.

**Why?** Simplicity. Circular dependencies complicate resolution.

#### Restriction 6: No global namespace conflicts

Plugins cannot export decorators with conflicting names.

**Why?** Clarity. Ambiguous decorators cause errors.

### Dependency Resolution

#### Resolution Algorithm

1. Parse opal.mod for all plugins
2. Build dependency graph
3. Detect circular dependencies (error if found)
4. Resolve version constraints
5. Download plugins (if not cached)
6. Verify checksums
7. Load DIM manifests (compile-time type checking)
8. Generate lock file (opal.lock)
9. Register all decorators globally

#### Lock File Commitment

```bash
# opal.lock should be committed to version control
git add opal.lock
git commit -m "Update plugin versions"

# This ensures reproducible builds across team
```

### Plugin Publishing

#### Publishing Workflow

```bash
# 1. Create plugin
mkdir opal-custom && cd opal-custom
opal init

# 2. Write decorators
cat > decorators/custom.opl << 'EOF'
fun custom.validate(rules: String) {
    @shell("validate --rules @var.rules")
}
EOF

# 3. Create DIM manifest
cat > dim.yaml << 'EOF'
apiVersion: opal.dev/dim/v1
plugin: { name: "company.custom", version: "1.0.0" }
decorators:
  - name: custom.validate
    kind: exec
    params:
      rules: { type: String }
EOF

# 4. Create plugin manifest
cat > opal.toml << 'EOF'
[package]
name = "company/custom"
version = "1.0.0"
authors = ["Team <team@company.com>"]

[decorators]
exports = ["custom.validate"]

[plugins]
wasm = "plugins/custom.wasm"
EOF

# 5. Verify plugin
opal verify

# 6. Publish to registry
opal publish
```

## Rationale

### Why no imports?

**Simplicity:** Plugins registered in opal.mod are available globally. No need for import statements.

**Clarity:** All available decorators visible in one place (opal.mod).

**Discoverability:** Easy to see what plugins are being used.

### Why host-driven execution?

**Control:** Opal remains in control of scheduling, IO, secrets, and determinism.

**Determinism:** Block execution is deterministic and verifiable.

**Security:** Secrets managed by host, never exposed to plugins.

**Composability:** Decorators like `@retry`, `@timeout` work transparently.

### Why WASM and native plugins?

**WASM:** Portable, sandboxed, language-agnostic.

**Native:** Performance-critical plugins can use native code.

**Choice:** Plugins can provide both; Opal chooses based on performance needs.

### Why registry-based distribution?

**Discoverability:** Users can search for plugins.

**Versioning:** Semantic versioning for dependencies.

**Trust:** Verified plugins in central registry.

**Caching:** Fast downloads with local cache.

### Why git repository sources?

**Flexibility:** Use any git hosting (GitHub, GitLab, private).

**Familiarity:** Same workflow as Go modules.

**Versioning:** Use git tags for versions.

**Private plugins:** Support private repositories.

## Alternatives Considered

### Alternative 1: No plugin system

**Rejected:** Limits code reuse and ecosystem growth.

### Alternative 2: Plugins execute blocks

**Rejected:** Loses host control. Breaks determinism and security.

### Alternative 3: Require imports

**Rejected:** Simpler to register globally in opal.mod.

### Alternative 4: No registry, git only

**Rejected:** Discoverability is important. Registry provides search and verification.

### Alternative 5: Only WASM plugins

**Rejected:** Performance-critical plugins need native code option.

## Implementation

### Phase 1: Plugin Registry
- Registry API design
- Registry server implementation
- Authentication and authorization
- Plugin publishing workflow

### Phase 2: Plugin Management
- opal.mod and opal.lock files
- Plugin installation from registry
- Dependency resolution
- Local caching

### Phase 3: Git Integration
- Git repository sources
- Version resolution (tags, branches, commits)
- SSH key authentication
- Caching strategy

### Phase 4: Plugin Execution
- DIM manifest loading and validation
- WASM runtime integration
- Native plugin loading
- RemoteContext implementation

### Phase 5: Terraform Provider Bridge
- Provider schema import
- Decorator generation
- Registry integration
- Provider execution

## Compatibility

**Breaking changes:** None. This is a new feature.

**Migration path:** N/A (new feature, no existing code to migrate).

## Open Questions

1. **Registry hosting:** Should we host a public registry, or allow self-hosted registries?
2. **Plugin versioning:** How should we handle plugin API versioning?
3. **Dependency conflicts:** How should we resolve version conflicts?
4. **Private registries:** Should we support private registries for enterprise?
5. **Plugin size limits:** What's the maximum size for plugins?
6. **Caching strategy:** Should we cache plugins globally or per-project?
7. **Offline mode:** Should plugins work offline (with cache)?
8. **Namespace management:** How should we prevent namespace squatting?
9. **Plugin signing:** Should plugins be cryptographically signed?
10. **Capability system:** How should we declare and enforce plugin capabilities?

## References

- **Go modules:** Inspiration for git repository sources and versioning
- **Terraform modules:** Inspiration for plugin structure and registry
- **Nix flakes:** Inspiration for reproducible builds and lock files
- **WebAssembly:** Standard for portable, sandboxed plugins
- **Related OEPs:**
  - OEP-009: Terraform/Pulumi Provider Bridge (provider integration)
  - OEP-006: LSP/IDE Integration (IDE support for plugins)
