---
oep: 012
title: Module Composition and Plugin System
status: Draft
type: Integration
created: 2025-01-21
updated: 2025-01-21
---

# OEP-012: Module Composition and Plugin System

## Summary

Add a comprehensive plugin system for sharing reusable decorators and schemas. Support WebAssembly and native plugins, registry-based distribution, and git repository sources. Plugins are registered globally via a mod file. Plugins provision resources and prepare transport contexts; Opal executes blocks remotely under the plugin's transport.

## Motivation

### The Problem

Current Opal has no plugin system:
- No way to share reusable decorators
- No way to distribute plugins
- No way to version dependencies
- No way to use git repositories as sources
- No plugin registry

### Use Cases

**1. Registry-based plugin installation:**
```bash
opal add hashicorp/aws@5.0.0
opal add company/custom-decorators@1.2.3
opal list
opal update hashicorp/aws
```

**2. Git repository sources:**
```bash
opal add github.com/company/opal-aws@v1.2.3
opal add gitlab.com/team/opal-utils@main
opal add git.company.com/ops/opal-internal@v2.0.0
```

**3. Global plugin usage (no imports needed):**
```opal
// opal.mod registers plugins globally
// All decorators available without import

deploy: {
    @aws.instance.deploy(name="web", ami="ami-123", type="t3.medium") {
        sudo systemctl enable nginx
        curl http://127.0.0.1/health
    }
}
```

**4. Terraform provider bridge:**
```bash
opal add terraform/hashicorp/aws@5.0.0
# Automatically generates decorators, available globally as @aws.*
```

## Proposal

### Plugin Registration (opal.mod)

#### Mod File Structure

```toml
# opal.mod - project plugin manifest
[plugins]
# Registry plugins
hashicorp/aws = "5.0.0"
company/custom = "1.2.3"

# Git repository plugins
github.com/company/opal-k8s = "v1.0.0"
gitlab.com/team/opal-utils = "main"

# Local plugins
./local/custom-plugin = "1.0.0"

# Terraform providers (auto-generates decorators)
terraform/hashicorp/aws = "5.0.0"
terraform/hashicorp/kubernetes = "2.0.0"
```

#### Lock File (opal.lock)

```toml
# opal.lock - generated by opal, committed to version control
[[plugin]]
name = "hashicorp/aws"
version = "5.0.0"
source = "registry+https://registry.opal.dev/hashicorp/aws"
checksum = "sha256:a1b2c3d4..."

[[plugin]]
name = "github.com/company/opal-k8s"
version = "v1.0.0"
source = "git+https://github.com/company/opal-k8s?tag=v1.0.0"
checksum = "sha256:e5f6g7h8..."
```

### Plugin Architecture

#### Plugin Responsibilities

Plugins are **host-driven**: they provision resources and prepare transport contexts, then hand execution back to Opal.

**Plugin responsibilities:**
1. **Plan-time advise**: Resolve intended resource spec, produce idempotency key
2. **Execute**:
   - Ensure resource exists (create or adopt by idempotency key)
   - Wait/ready: probe until reachable (port open, SSM online, etc.)
   - Prepare transport handle (SSH, SSM, or other)
   - Return handle to host (never execute block inside plugin)

#### Host Responsibilities

Opal (the host) remains in control:

1. **Wrap execution context** with RemoteContext from plugin
2. **Execute block steps** via wrapped context:
   - Schedule child steps (deterministic order)
   - Handle `@retry`, `@timeout`, secret scrubbing
   - Deterministic output merge
3. **Teardown** after block completes

#### Execution Flow

```
1. Plan: decorator appears with params; block exists → marked "remote block"

2. Run:
   - BeginExec(params) → returns remote_handle(transport, targets, user, host)
   - Host: ctx' = ctx.WithRemote(remote_handle)
   - Host: ExecuteBlock(block) under ctx'
   - EndExec(token)

3. WithRemote redirects:
   - @shell commands run over SSH/SSM
   - Environment variables passed to remote
   - Files transferred as needed
   - Stdout/stderr kept deterministic and scrubbed
```

### Plugin Interface (DIM Manifest)

Plugins declare their interface via a DIM (Decorator Interface Manifest) file:

```yaml
apiVersion: opal.dev/dim/v1
plugin: { name: "aws.ec2", version: "1.0.0", min_core: "0.4.0" }
decorators:
  - name: aws.instance.deploy
    kind: exec
    determinism: deterministic
    params:
      name:            { type: String }
      ami:             { type: String }
      type:            { type: String }
      region:          { type: String }
      count:           { type: Int, default: 1, min: 1 }
      idempotenceKey:  { type: Array, items: {type:String}, optional: true }
      transport:       { type: Enum, values: ["ssh","ssm"], default: "ssm" }
      ssh_user:        { type: String, optional: true }
      ssh_key_ref:     { type: String, secret: true, optional: true }
      ready_probe:     { type: Object, optional: true,
                         props: { port:{type:Int,optional:true},
                                 cmd:{type:String,optional:true},
                                 timeout:{type:Duration,default:"5m"} } }
      max_concurrency: { type: Int, default: 5, min: 1 }
      tolerate:        { type: Int, default: 0, min: 0 }
    block: optional   # block allowed; if present → remote context
    capabilities: ["net","clock"]
```

### Plugin Execution ABIs

**Language-agnostic:** WASM and native (.so) plugins can be implemented in any language that compiles to WebAssembly or native code (Rust, Go, C++, Zig, AssemblyScript, etc.).

#### WASM ABI

Plugins implement these functions:

**BeginExec** (create/ensure resource)
- Input: `params_json`
- Output: `policy_token`, `remote_handle_json` (targets, transport, user), `teardown_hint`

**OnChildStart/Finish** (optional policy hooks)
- For telemetry or per-target failure policy

**EndExec** (cleanup)
- Input: `policy_token`, `teardown_hint`
- Allows cleanup using plugin's internal state

#### Native Plugin ABI

Native plugins (`.so` files) implement C-compatible vtable:

```c
typedef struct {
    void* (*begin_exec)(const char* params_json, char** remote_handle_json, char** teardown_hint);
    void (*on_child_start)(void* token, int target_idx);
    void (*on_child_finish)(void* token, int target_idx, int exit_code);
    void (*end_exec)(void* token, const char* teardown_hint);
} OpalPluginVTable;
```

### Plugin Structure

#### Plugin Package

```
opal-aws/
├── opal.toml                 # Plugin manifest
├── dim.yaml                  # Decorator interface manifest
├── decorators/
│   ├── instance.opl
│   ├── s3.opl
│   └── rds.opl
├── schemas/
│   ├── instance.schema.json
│   └── s3.schema.json
├── plugins/
│   ├── aws-provider.wasm     # WebAssembly plugin
│   └── aws-provider.so       # Native plugin (optional)
└── README.md
```

#### Plugin Manifest (opal.toml)

```toml
[package]
name = "hashicorp/aws"
version = "5.0.0"
authors = ["HashiCorp <team@hashicorp.com>"]
description = "AWS provider for Opal"
license = "MPL-2.0"
repository = "https://github.com/hashicorp/opal-aws"

[dependencies]
"opal/core" = "^0.1.0"

[decorators]
# Exported decorators (available globally)
exports = [
    "aws.instance.deploy",
    "aws.s3.bucket.ensure",
    "aws.rds.create"
]

[plugins]
# WebAssembly plugin (recommended)
wasm = "plugins/aws-provider.wasm"
# Native plugin (optional, for performance)
native = "plugins/aws-provider.so"
```

### Plugin Registry

#### Registry Structure

```
registry.opal.dev/
├── hashicorp/
│   ├── aws/
│   │   ├── 5.0.0/
│   │   │   ├── plugin.tar.gz
│   │   │   ├── plugin.tar.gz.sha256
│   │   │   └── manifest.json
│   │   └── versions.json
│   └── terraform/
│       └── ...
└── company/
    └── custom-decorators/
        └── ...
```

#### Registry Commands

```bash
# Add plugin from registry
opal add hashicorp/aws@5.0.0

# Add from git repository
opal add github.com/company/opal-aws@v1.2.3

# Update plugin
opal update hashicorp/aws

# Remove plugin
opal remove hashicorp/aws

# List installed plugins
opal list

# Search registry
opal search aws

# Show plugin info
opal info hashicorp/aws
```

### Git Repository Integration

#### Adding from Git

```bash
# Add from GitHub
opal add github.com/company/opal-aws@v1.2.3

# Add from GitLab
opal add gitlab.com/team/opal-utils@main

# Add from private repo (uses SSH keys)
opal add git@github.com:company/private-plugin.git@v2.0.0
```

#### Version Resolution

```bash
# Semantic versioning
opal add github.com/company/plugin@v1.2.3  # Exact version
opal add github.com/company/plugin@v1.2    # Latest patch (1.2.x)
opal add github.com/company/plugin@v1      # Latest minor (1.x.x)

# Git references
opal add github.com/company/plugin@main    # Branch
opal add github.com/company/plugin@abc123  # Commit hash
opal add github.com/company/plugin@v1.2.3  # Tag
```

### Core Restrictions

#### Restriction 1: Plugins are immutable

Once published, plugin versions cannot be modified.

**Why?** Reproducibility. Builds must be deterministic.

#### Restriction 2: Plugins never execute blocks

Plugins provision resources and return transport context. Opal executes blocks.

**Why?** Host remains in control. Determinism and security.

#### Restriction 3: Plugins cannot write to stdout

Plugins must return opaque handles. No raw secrets in logs.

**Why?** Security. Secrets must be scrubbed.

#### Restriction 4: Version constraints must be explicit

Dependencies must specify version constraints (no wildcards).

**Why?** Reproducibility. Builds must be deterministic.

#### Restriction 5: Circular dependencies are forbidden

Plugins cannot have circular dependencies.

**Why?** Simplicity. Circular dependencies complicate resolution.

#### Restriction 6: No global namespace conflicts

Plugins cannot export decorators with conflicting names.

**Why?** Clarity. Ambiguous decorators cause errors.

### Dependency Resolution

#### Resolution Algorithm

1. Parse opal.mod for all plugins
2. Build dependency graph
3. Detect circular dependencies (error if found)
4. Resolve version constraints
5. Download plugins (if not cached)
6. Verify checksums
7. Load DIM manifests (compile-time type checking)
8. Generate lock file (opal.lock)
9. Register all decorators globally

#### Lock File Commitment

```bash
# opal.lock should be committed to version control
git add opal.lock
git commit -m "Update plugin versions"

# This ensures reproducible builds across team
```

### Plugin Publishing

#### Publishing Workflow

```bash
# 1. Create plugin
mkdir opal-custom && cd opal-custom
opal init

# 2. Write decorators
cat > decorators/custom.opl << 'EOF'
fun custom.validate(rules: String) {
    @shell("validate --rules @var.rules")
}
EOF

# 3. Create DIM manifest
cat > dim.yaml << 'EOF'
apiVersion: opal.dev/dim/v1
plugin: { name: "company.custom", version: "1.0.0" }
decorators:
  - name: custom.validate
    kind: exec
    params:
      rules: { type: String }
EOF

# 4. Create plugin manifest
cat > opal.toml << 'EOF'
[package]
name = "company/custom"
version = "1.0.0"
authors = ["Team <team@company.com>"]

[decorators]
exports = ["custom.validate"]

[plugins]
wasm = "plugins/custom.wasm"
EOF

# 5. Verify plugin
opal verify

# 6. Publish to registry
opal publish
```

## Rationale

### Why no imports?

**Simplicity:** Plugins registered in opal.mod are available globally. No need for import statements.

**Clarity:** All available decorators visible in one place (opal.mod).

**Discoverability:** Easy to see what plugins are being used.

### Why host-driven execution?

**Control:** Opal remains in control of scheduling, IO, secrets, and determinism.

**Determinism:** Block execution is deterministic and verifiable.

**Security:** Secrets managed by host, never exposed to plugins.

**Composability:** Decorators like `@retry`, `@timeout` work transparently.

### Why WASM and native plugins?

**WASM:** Portable, sandboxed, language-agnostic.

**Native:** Performance-critical plugins can use native code.

**Choice:** Plugins can provide both; Opal chooses based on performance needs.

### Why registry-based distribution?

**Discoverability:** Users can search for plugins.

**Versioning:** Semantic versioning for dependencies.

**Trust:** Verified plugins in central registry.

**Caching:** Fast downloads with local cache.

### Why git repository sources?

**Flexibility:** Use any git hosting (GitHub, GitLab, private).

**Familiarity:** Same workflow as Go modules.

**Versioning:** Use git tags for versions.

**Private plugins:** Support private repositories.

## Alternatives Considered

### Alternative 1: No plugin system

**Rejected:** Limits code reuse and ecosystem growth.

### Alternative 2: Plugins execute blocks

**Rejected:** Loses host control. Breaks determinism and security.

### Alternative 3: Require imports

**Rejected:** Simpler to register globally in opal.mod.

### Alternative 4: No registry, git only

**Rejected:** Discoverability is important. Registry provides search and verification.

### Alternative 5: Only WASM plugins

**Rejected:** Performance-critical plugins need native code option.

## Implementation

### Phase 1: Plugin Registry
- Registry API design
- Registry server implementation
- Authentication and authorization
- Plugin publishing workflow

### Phase 2: Plugin Management
- opal.mod and opal.lock files
- Plugin installation from registry
- Dependency resolution
- Local caching

### Phase 3: Git Integration
- Git repository sources
- Version resolution (tags, branches, commits)
- SSH key authentication
- Caching strategy

### Phase 4: Plugin Execution
- DIM manifest loading and validation
- WASM runtime integration
- Native plugin loading
- RemoteContext implementation

### Phase 5: Terraform Provider Bridge
- Provider schema import
- Decorator generation
- Registry integration
- Provider execution

## Compatibility

**Breaking changes:** None. This is a new feature.

**Migration path:** N/A (new feature, no existing code to migrate).

## Open Questions

1. **Registry hosting:** Should we host a public registry, or allow self-hosted registries?
2. **Plugin versioning:** How should we handle plugin API versioning?
3. **Dependency conflicts:** How should we resolve version conflicts?
4. **Private registries:** Should we support private registries for enterprise?
5. **Plugin size limits:** What's the maximum size for plugins?
6. **Caching strategy:** Should we cache plugins globally or per-project?
7. **Offline mode:** Should plugins work offline (with cache)?
8. **Namespace management:** How should we prevent namespace squatting?
9. **Plugin signing:** Should plugins be cryptographically signed?
10. **Capability system:** How should we declare and enforce plugin capabilities?

## References

- **Go modules:** Inspiration for git repository sources and versioning
- **Terraform modules:** Inspiration for plugin structure and registry
- **Nix flakes:** Inspiration for reproducible builds and lock files
- **WebAssembly:** Standard for portable, sandboxed plugins
- **Related OEPs:**
  - OEP-009: Terraform/Pulumi Provider Bridge (provider integration)
  - OEP-006: LSP/IDE Integration (IDE support for plugins)
